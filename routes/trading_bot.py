"""
A simple Flask blueprint exposing a `/trading-bot` endpoint that accepts a list
of news events and candlestick data and returns trading decisions based on a
very basic heuristic.

**Disclaimer:** This implementation is provided for educational purposes only
and does not constitute financial advice. There is no guarantee that the
decisions generated by this code will be profitable or appropriate for actual
trading. Use it at your own risk.
"""

from flask import Blueprint, request, jsonify

bp = Blueprint("trading_bot", __name__)

from routes import app


@bp.route("/trading-bot", methods=["POST"])
def trading_bot() -> tuple:
    """Endpoint that processes incoming news events and returns trading decisions.

    The request body must be a JSON array of objects, each of which should
    include at least the following keys:
      - ``id`` (int): a unique identifier for the news event.
      - ``observation_candles`` (list): a list of candlestick objects. Each
        candlestick is expected to include a ``close`` price. Only the first
        and last candles in this list are used by the heuristic.

    The response is a JSON array of up to 50 objects, each containing:
      - ``id``: copied from the input event.
      - ``decision``: either ``"LONG"`` or ``"SHORT"``, indicating whether
        the algorithm believes the price will rise or fall based on the
        observation period. Decisions are sorted by the magnitude of the price
        change so that the most decisive events are selected when there are
        more than 50 events.

    :returns: A tuple of (JSON response, HTTP status code).
    """
    # Attempt to parse the request body as JSON. If parsing fails or the
    # payload is not a list, return a 400 error.
    data = request.get_json(silent=True)
    if not isinstance(data, list):
        return jsonify({"error": "Invalid input format; expected a JSON array."}), 400

    # Prepare a list to hold scored decisions. Each element is a tuple of
    # (abs_delta, event_id, decision). The abs_delta is used to sort events by
    # the magnitude of their price change.
    scored_events: list[tuple[float, int, str]] = []

    for event in data:
        # Validate that the event has an id and observation candles
        event_id = event.get("id")
        obs_candles = event.get("observation_candles")
        if event_id is None or not obs_candles:
            continue

        try:
            # Extract the first and last candle close prices
            first_candle = obs_candles[0]
            last_candle = obs_candles[-1]
            first_close = float(first_candle.get("close"))
            last_close = float(last_candle.get("close"))

            # Compute the change in price over the observation period
            delta = last_close - first_close
            abs_delta = abs(delta)

            # Determine the trading decision based on the sign of the change
            decision = "LONG" if delta >= 0 else "SHORT"

            scored_events.append((abs_delta, event_id, decision))
        except (TypeError, ValueError):
            # Skip events with missing or non-numeric data
            continue

    # Sort events by absolute price change descending; this prioritises events
    # where the price moved the most during the observation period.
    scored_events.sort(key=lambda x: x[0], reverse=True)

    # Select the top 50 events (or fewer if fewer events were scored)
    selected_events = scored_events[:50]

    # Build the response payload
    response_payload = [
        {"id": event_id, "decision": decision}
        for _, event_id, decision in selected_events
    ]

    return jsonify(response_payload), 200